# Key Objects

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-klara.core.decorators.deprecated-start--->
## klara.core.decorators.deprecated

<!---Documatic-section-deprecated-start--->
<!---Documatic-block-klara.core.decorators.deprecated-start--->
<details>
	<summary><code>klara.core.decorators.deprecated</code> code snippet</summary>

```python
def deprecated(func):

    @functools.wraps(func)
    def new_func(*args, **kwargs):
        warnings.simplefilter('always', DeprecationWarning)
        warnings.warn('Call to deprecated function {}.'.format(func.__name__), category=DeprecationWarning, stacklevel=2)
        warnings.simplefilter('default', DeprecationWarning)
        return func(*args, **kwargs)
    return new_func
```
</details>
<!---Documatic-block-klara.core.decorators.deprecated-end--->
<!---Documatic-section-deprecated-end--->

# #
<!---Documatic-section-klara.core.decorators.deprecated-end--->

<!---Documatic-section-klara.core.source_utils.get_default_stub_files-start--->
## klara.core.source_utils.get_default_stub_files

<!---Documatic-section-get_default_stub_files-start--->
<!---Documatic-block-klara.core.source_utils.get_default_stub_files-start--->
<details>
	<summary><code>klara.core.source_utils.get_default_stub_files</code> code snippet</summary>

```python
def get_default_stub_files():
    results = []
    for module in os.listdir(PLUGINS_DIR):
        if module.endswith('.pyi'):
            results.append(os.path.join(PLUGINS_DIR, module))
    return results
```
</details>
<!---Documatic-block-klara.core.source_utils.get_default_stub_files-end--->
<!---Documatic-section-get_default_stub_files-end--->

# #
<!---Documatic-section-klara.core.source_utils.get_default_stub_files-end--->

<!---Documatic-section-klara.scripts.cover_gen_ins.config.ConfigNamespace-start--->
## klara.scripts.cover_gen_ins.config.ConfigNamespace

<!---Documatic-section-ConfigNamespace-start--->
<!---Documatic-block-klara.scripts.cover_gen_ins.config.ConfigNamespace-start--->
<details>
	<summary><code>klara.scripts.cover_gen_ins.config.ConfigNamespace</code> code snippet</summary>

```python
class ConfigNamespace(Config):
    file_name: list = []
    force_infer = False
    entry_class: str = ''
    entry_func: str = 'Top'
    output_file = None
    z3_parallel = False
    z3_parallel_max_threads = None
    output_statistics = None
    mss_algorithm = 'z3'
    cover_lines = []
    cover_all = False
    cover_return = False
```
</details>
<!---Documatic-block-klara.scripts.cover_gen_ins.config.ConfigNamespace-end--->
<!---Documatic-section-ConfigNamespace-end--->

# #
<!---Documatic-section-klara.scripts.cover_gen_ins.config.ConfigNamespace-end--->

<!---Documatic-section-klara.core.use_def_chain.link_stmts_to_def-start--->
## klara.core.use_def_chain.link_stmts_to_def

<!---Documatic-section-link_stmts_to_def-start--->
```mermaid
flowchart LR
klara.core.use_def_chain.link_stmts_to_def-->klara.core.use_def_chain.link
```

### Object Calls

* klara.core.use_def_chain.link

<!---Documatic-block-klara.core.use_def_chain.link_stmts_to_def-start--->
<details>
	<summary><code>klara.core.use_def_chain.link_stmts_to_def</code> code snippet</summary>

```python
def link_stmts_to_def(ssa, allow_uninitialized=False, target_phi=False):
    if target_phi is True and ssa.statement().is_phi is True or (target_phi is False and ssa.statement().is_phi is False):
        DefUseLinker.link(ssa, allow_uninitialized)
```
</details>
<!---Documatic-block-klara.core.use_def_chain.link_stmts_to_def-end--->
<!---Documatic-section-link_stmts_to_def-end--->

# #
<!---Documatic-section-klara.core.use_def_chain.link_stmts_to_def-end--->

<!---Documatic-section-klara.__init__.parse_node-start--->
## klara.__init__.parse_node

<!---Documatic-section-parse_node-start--->
<!---Documatic-block-klara.__init__.parse_node-start--->
<details>
	<summary><code>klara.__init__.parse_node</code> code snippet</summary>

```python
def parse_node(source: str, py2: bool=False) -> namedtuple:
    MANAGER.config.py_version = 2 if py2 else 3
    MANAGER.reload_protocol()
    (tree, value) = _extract_node(source, py2)
    MANAGER.apply_transform(tree)
    MANAGER.build_cfg(tree)
    return value
```
</details>
<!---Documatic-block-klara.__init__.parse_node-end--->
<!---Documatic-section-parse_node-end--->

# #
<!---Documatic-section-klara.__init__.parse_node-end--->

<!---Documatic-section-klara.scripts.py_check.result_banner.decorate-start--->
## klara.scripts.py_check.result_banner.decorate

<!---Documatic-section-decorate-start--->
<!---Documatic-block-klara.scripts.py_check.result_banner.decorate-start--->
<details>
	<summary><code>klara.scripts.py_check.result_banner.decorate</code> code snippet</summary>

```python
def decorate(keyword):

    def wrapper(f):

        def _(*args, **kwargs):
            res = f(*args, **kwargs)
            if res:
                res = '\n'.join(('-' * (len(keyword) + 2), '|{}|'.format(keyword), '-' * (len(keyword) + 2), res))
            return res
        return _
    return wrapper
```
</details>
<!---Documatic-block-klara.scripts.py_check.result_banner.decorate-end--->
<!---Documatic-section-decorate-end--->

# #
<!---Documatic-section-klara.scripts.py_check.result_banner.decorate-end--->

<!---Documatic-section-klara.core.tree.infer_proxy.InferProxy-start--->
## klara.core.tree.infer_proxy.InferProxy

<!---Documatic-section-InferProxy-start--->
<!---Documatic-block-klara.core.tree.infer_proxy.InferProxy-start--->
<details>
	<summary><code>klara.core.tree.infer_proxy.InferProxy</code> code snippet</summary>

```python
class InferProxy(nodes.Const):
    _fields = ()

    def __init__(self, value=None):
        super(InferProxy, self).__init__(value)
        self._infer_binop = self._default_op
        self._infer_comp_op = self._default_op
        self._hash = None

    def dunder_lookup(self, method):
        if method is not None:
            method = self._convert_dunder(method)
            return getattr(self, method)

    def _default_op(self, op: str, other: inference.InferenceResult, method_name: str, context=None, self_result=inference.InferenceResult):
        method = self.dunder_lookup(method_name)
        if method and other.status:
            res = method(other.result)
            res = res + other + self_result
            yield res
        else:
            MANAGER.logger.warning('Z3', 'Error in inferring of node: {}, op: {}, other: {}'.format(self, op, other.result))
            yield inference.InferenceResult.load_result(nodes.Uninferable(), inference_results=(other, self_result))

    def _infer_builtins(self, builtin: str, context):
        method = self.dunder_lookup('__' + builtin + '__')
        if method:
            yield method()
        else:
            MANAGER.logger.warning('Z3', 'Builtin function {} not defined in class: {}', builtin, str(type(self)))
            yield inference.InferenceResult.load_result(nodes.Uninferable())

    def _infer_unaryop(self, op, method_name, context=None):

        def fail():
            MANAGER.logger.warning('Z3', 'unary operation: {} failed on Z3 value: {}', op, self.value)
        method = self.dunder_lookup(method_name)
        if op == 'not':
            method = self.dunder_lookup('__not_bool__')
            if method:
                yield from method()
            else:
                fail()
                yield inference.InferenceResult.load_result(nodes.Uninferable())
        elif method:
            res = method()
            yield res
        else:
            fail()
            yield inference.InferenceResult.load_result(nodes.Uninferable())

    def _infer_bool(self, context=None):
        method = self.dunder_lookup('__bool__')
        if method:
            yield from method()
        else:
            MANAGER.logger.warning('Z3', 'bool operation failed on Z3 value: {}', self.value)
            yield inference.InferenceResult.load_result(nodes.Uninferable())

    def to_ast(self) -> ast.AST:
        """
        Specify how to convert this node to ast expression, to be used as test case comparison
        :return: ast node
        """
        return super(InferProxy, self).to_ast()

    @staticmethod
    def _convert_dunder(dunder: str):
        """
        convert dunder method string to klara's specification
        :param dunder: dunder method in string, e.g. __str__
        :return: converted dunder
        """
        return '__k_' + dunder[2:]

    def __iter__(self):
        return self

    def __next__(self):
        raise StopIteration

    def _infer(self, context=None):
        yield inference.InferenceResult.load_result(self, substituted=True)

    def infer(self, context=None, inferred_attr=None):
        if not context or not context.model:
            yield inference.InferenceResult.load_result(self, substituted=True)
        else:
            yield from self._infer(context)

    def get_return_type(self):
        return type(None)

    def hash(self):
        return hash(self.value)

    def __hash__(self):
        if self._hash is not None:
            return self._hash
        self._hash = self.hash()
        return self._hash
```
</details>
<!---Documatic-block-klara.core.tree.infer_proxy.InferProxy-end--->
<!---Documatic-section-InferProxy-end--->

# #
<!---Documatic-section-klara.core.tree.infer_proxy.InferProxy-end--->

<!---Documatic-section-klara.__init__.parse-start--->
## klara.__init__.parse

<!---Documatic-section-parse-start--->
<!---Documatic-block-klara.__init__.parse-start--->
<details>
	<summary><code>klara.__init__.parse</code> code snippet</summary>

```python
def parse(source: str, py2: bool=False) -> Module:
    MANAGER.config.py_version = 2 if py2 else 3
    tree = MANAGER.build_tree(source)
    MANAGER.build_cfg(tree)
    return tree
```
</details>
<!---Documatic-block-klara.__init__.parse-end--->
<!---Documatic-section-parse-end--->

# #
<!---Documatic-section-klara.__init__.parse-end--->

<!---Documatic-section-klara.core.decorators.cachedproperty-start--->
## klara.core.decorators.cachedproperty

<!---Documatic-section-cachedproperty-start--->
<!---Documatic-block-klara.core.decorators.cachedproperty-start--->
<details>
	<summary><code>klara.core.decorators.cachedproperty</code> code snippet</summary>

```python
class cachedproperty:
    __slots__ = ('wrapped',)

    def __init__(self, wrapped):
        try:
            wrapped.__name__
        except AttributeError as exc:
            raise TypeError('%s must have a __name__ attribute' % wrapped) from exc
        self.wrapped = wrapped

    @property
    def __doc__(self):
        doc = getattr(self.wrapped, '__doc__', None)
        return '<wrapped by the cachedproperty decorator>%s' % ('\n%s' % doc if doc else '')

    def __get__(self, inst, objtype=None):
        if inst is None:
            return self
        val = self.wrapped(inst)
        setattr(inst, self.wrapped.__name__, val)
        return val
```
</details>
<!---Documatic-block-klara.core.decorators.cachedproperty-end--->
<!---Documatic-section-cachedproperty-end--->

# #
<!---Documatic-section-klara.core.decorators.cachedproperty-end--->

<!---Documatic-section-klara.common.cfg_common.GraphWalker-start--->
## klara.common.cfg_common.GraphWalker

<!---Documatic-section-GraphWalker-start--->
<!---Documatic-block-klara.common.cfg_common.GraphWalker-start--->
<details>
	<summary><code>klara.common.cfg_common.GraphWalker</code> code snippet</summary>

```python
class GraphWalker:

    def __init__(self, root):
        self.root = root
        self._call_str = ''
        self.closed_block = set()
        self.queue = deque()
        self.blocked_by_call_string = dict()
        self.processed_call_string = set()

    def walk_bfs(self):
        if not self.root:
            return
        self.queue.append(self.root)
        for block in self._walk_bfs():
            yield block

    def _walk_bfs(self):
        while len(self.queue) != 0:
            block = self.queue.popleft()
            if block:
                yield block
                for nxt_blk in block.nxt_block_list:
                    if nxt_blk not in self.queue and nxt_blk not in self.closed_block:
                        self.queue.append(nxt_blk)
                self.closed_block.add(block)

    def walk_dfs(self):
        walk_record = []
        for block in self._walk_dfs(walk_record, self.root):
            yield block

    def _walk_dfs(self, walk_record, basic_block):
        """
        yield nodes from bottom
        :return:
        """
        if basic_block is None:
            return
        walk_record.append(basic_block)
        for next_block in basic_block.nxt_block_list:
            if next_block not in walk_record and next_block is not None:
                for block in self._walk_dfs(walk_record, next_block):
                    yield block
        for block in reversed(self.queue):
            if block not in walk_record and block is not None:
                for block in self._walk_dfs(walk_record, block):
                    yield block
        yield basic_block
```
</details>
<!---Documatic-block-klara.common.cfg_common.GraphWalker-end--->
<!---Documatic-section-GraphWalker-end--->

# #
<!---Documatic-section-klara.common.cfg_common.GraphWalker-end--->

<!---Documatic-section-klara.common.cfg_common.find_blocks_involved-start--->
## klara.common.cfg_common.find_blocks_involved

<!---Documatic-section-find_blocks_involved-start--->
```mermaid
flowchart LR
klara.common.cfg_common.find_blocks_involved-->klara.common.cfg_common.GraphWalker
```

### Object Calls

* klara.common.cfg_common.GraphWalker

<!---Documatic-block-klara.common.cfg_common.find_blocks_involved-start--->
<details>
	<summary><code>klara.common.cfg_common.find_blocks_involved</code> code snippet</summary>

```python
def find_blocks_involved(root, block_list):
    if root not in block_list:
        block_list.append(root)
    block_involved = []
    for block in GraphWalker(root).walk_bfs():
        block_involved.append(block)
    result = [blk for blk in block_list if blk in block_involved]
    return result
```
</details>
<!---Documatic-block-klara.common.cfg_common.find_blocks_involved-end--->
<!---Documatic-section-find_blocks_involved-end--->

# #
<!---Documatic-section-klara.common.cfg_common.find_blocks_involved-end--->

<!---Documatic-section-klara.__init__.initialize-start--->
## klara.__init__.initialize

<!---Documatic-section-initialize-start--->
<!---Documatic-block-klara.__init__.initialize-start--->
<details>
	<summary><code>klara.__init__.initialize</code> code snippet</summary>

```python
def initialize(config: Config=None, smt_disable: bool=False) -> None:
    if smt_disable:
        manager = _core_manager.AstManager()
        manager.initialize(config or Config())
        _infer_extension.disable()
    else:
        MANAGER.initialize(config or Config())
        _infer_extension.enable()
```
</details>
<!---Documatic-block-klara.__init__.initialize-end--->
<!---Documatic-section-initialize-end--->

# #
<!---Documatic-section-klara.__init__.initialize-end--->

<!---Documatic-section-klara.core.source_utils.get_plugins_files-start--->
## klara.core.source_utils.get_plugins_files

<!---Documatic-section-get_plugins_files-start--->
<!---Documatic-block-klara.core.source_utils.get_plugins_files-start--->
<details>
	<summary><code>klara.core.source_utils.get_plugins_files</code> code snippet</summary>

```python
def get_plugins_files():
    results = []
    for module in os.listdir(PLUGINS_DIR):
        if module.endswith('.py'):
            results.append(os.path.join(PLUGINS_DIR, module))
    return results
```
</details>
<!---Documatic-block-klara.core.source_utils.get_plugins_files-end--->
<!---Documatic-section-get_plugins_files-end--->

# #
<!---Documatic-section-klara.core.source_utils.get_plugins_files-end--->

<!---Documatic-section-klara.core.tree_rewriter.AstBuilder-start--->
## klara.core.tree_rewriter.AstBuilder

<!---Documatic-section-AstBuilder-start--->
<!---Documatic-block-klara.core.tree_rewriter.AstBuilder-start--->
<details>
	<summary><code>klara.core.tree_rewriter.AstBuilder</code> code snippet</summary>

```python
class AstBuilder:

    def __init__(self, py2=False, tree_rewriter=None):
        self._py2 = py2
        self._tree_rewriter = tree_rewriter or TreeRewriter

    def string_build(self, ast_str, name='', **kwargs):
        old_tree = _ast.parse(dedent(ast_str), self._py2)
        return self._tree_rewriter(parser_mod=_ast.get_parser_module(), py2=self._py2, **kwargs).visit_module(old_tree, name=name)

    def file_build(self, file_path, relative=False, **kwargs):
        fp = pathlib.Path(file_path)
        return self.string_build(fp.read_text(), **kwargs)
```
</details>
<!---Documatic-block-klara.core.tree_rewriter.AstBuilder-end--->
<!---Documatic-section-AstBuilder-end--->

# #
<!---Documatic-section-klara.core.tree_rewriter.AstBuilder-end--->

<!---Documatic-section-klara.core.utilities.methdispatch-start--->
## klara.core.utilities.methdispatch

<!---Documatic-section-methdispatch-start--->
<!---Documatic-block-klara.core.utilities.methdispatch-start--->
<details>
	<summary><code>klara.core.utilities.methdispatch</code> code snippet</summary>

```python
def methdispatch(func):
    dispatcher = singledispatch(func)

    def wrapper(*args, **kw):
        return dispatcher.dispatch(args[1].__class__)(*args, **kw)
    wrapper.register = dispatcher.register
    update_wrapper(wrapper, func)
    return wrapper
```
</details>
<!---Documatic-block-klara.core.utilities.methdispatch-end--->
<!---Documatic-section-methdispatch-end--->

# #
<!---Documatic-section-klara.core.utilities.methdispatch-end--->

<!---Documatic-section-klara.core.protocols.py2_div-start--->
## klara.core.protocols.py2_div

<!---Documatic-section-py2_div-start--->
<!---Documatic-block-klara.core.protocols.py2_div-start--->
<details>
	<summary><code>klara.core.protocols.py2_div</code> code snippet</summary>

```python
def py2_div(a, b):
    if any((type(i) is float for i in (a, b))):
        return a / b
    else:
        return a // b
```
</details>
<!---Documatic-block-klara.core.protocols.py2_div-end--->
<!---Documatic-section-py2_div-end--->

# #
<!---Documatic-section-klara.core.protocols.py2_div-end--->

<!---Documatic-section-klara.core.tree_rewriter.extract_node-start--->
## klara.core.tree_rewriter.extract_node

<!---Documatic-section-extract_node-start--->
```mermaid
flowchart LR
klara.core.tree_rewriter.extract_node-->klara.core.tree_rewriter.AstBuilder
```

### Object Calls

* klara.core.tree_rewriter.AstBuilder

<!---Documatic-block-klara.core.tree_rewriter.extract_node-start--->
<details>
	<summary><code>klara.core.tree_rewriter.extract_node</code> code snippet</summary>

```python
def extract_node(code, py2=False):
    requested_lines = {}
    for (idx, line) in enumerate(code.splitlines()):
        match = re.match('.*{}\\s*(?P<name>\\w*)\\s*\\(*(?P<member>\\w*)\\)*'.format(_STATEMENT_SELECTOR), line.strip())
        if match:
            name = match.group('name')
            member = match.group('member')
            requested_lines[idx + 1] = (name, member)
    tree = AstBuilder(py2).string_build(code)
    if not tree.body:
        raise ValueError('Empty tree, cannot extract.')
    if not requested_lines:
        return (tree, tree)
    statement_extractor = ssa_visitors.StatementExprExtractor(requested_lines)
    value = statement_extractor.extract(tree)
    return (tree, value)
```
</details>
<!---Documatic-block-klara.core.tree_rewriter.extract_node-end--->
<!---Documatic-section-extract_node-end--->

# #
<!---Documatic-section-klara.core.tree_rewriter.extract_node-end--->

<!---Documatic-section-klara.klara_z3.z3_nodes.handle_z3_exceptions-start--->
## klara.klara_z3.z3_nodes.handle_z3_exceptions

<!---Documatic-section-handle_z3_exceptions-start--->
<!---Documatic-block-klara.klara_z3.z3_nodes.handle_z3_exceptions-start--->
<details>
	<summary><code>klara.klara_z3.z3_nodes.handle_z3_exceptions</code> code snippet</summary>

```python
def handle_z3_exceptions(f):

    def wrapper(*args, **kwargs):
        try:
            yield from f(*args, **kwargs)
        except z3.Z3Exception:
            yield inference.InferenceResult.load_result(nodes.Uninferable())
    return wrapper
```
</details>
<!---Documatic-block-klara.klara_z3.z3_nodes.handle_z3_exceptions-end--->
<!---Documatic-section-handle_z3_exceptions-end--->

# #
<!---Documatic-section-klara.klara_z3.z3_nodes.handle_z3_exceptions-end--->

<!---Documatic-section-klara.core.use_def_chain.link-start--->
## klara.core.use_def_chain.link

<!---Documatic-section-link-start--->
<!---Documatic-block-klara.core.use_def_chain.link-start--->
<details>
	<summary><code>klara.core.use_def_chain.link</code> code snippet</summary>

```python
def link(node):
    if not node.is_name_constant():
        try:
            def_stmt = node.instance().locals.get(node.get_var_repr())
            node.links = def_stmt
        except (exceptions.InstanceNotExistError, NotImplementedError, AttributeError):
            pass
```
</details>
<!---Documatic-block-klara.core.use_def_chain.link-end--->
<!---Documatic-section-link-end--->

# #
<!---Documatic-section-klara.core.use_def_chain.link-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)